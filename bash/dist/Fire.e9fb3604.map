{"version":3,"sources":["node_modules/three/examples/js/objects/Fire.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Fire.e9fb3604.map","sourceRoot":"..","sourcesContent":["/**\n * @author Mike Piecuch / https://github.com/mikepiecuch\n *\n * Based on research paper \"Real-Time Fluid Dynamics for Games\" by Jos Stam\n * http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf\n *\n */\n\nTHREE.Fire = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Fire';\n\n\tthis.clock = new THREE.Clock();\n\n\toptions = options || {};\n\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar oneOverWidth = 1.0 / textureWidth;\n\tvar oneOverHeight = 1.0 / textureHeight;\n\n\tvar debug = ( options.debug === undefined ) ? false : options.debug;\n\tthis.color1 = options.color1 || new THREE.Color( 0xffffff );\n\tthis.color2 = options.color2 || new THREE.Color( 0xffa000 );\n\tthis.color3 = options.color3 || new THREE.Color( 0x000000 );\n\tthis.colorBias = ( options.colorBias === undefined ) ? 0.8 : options.colorBias;\n\tthis.diffuse = ( options.diffuse === undefined ) ? 1.33 : options.diffuse;\n\tthis.viscosity = ( options.viscosity === undefined ) ? 0.25 : options.viscosity;\n\tthis.expansion = ( options.expansion === undefined ) ? - 0.25 : options.expansion;\n\tthis.swirl = ( options.swirl === undefined ) ? 50.0 : options.swirl;\n\tthis.burnRate = ( options.burnRate === undefined ) ? 0.3 : options.burnRate;\n\tthis.drag = ( options.drag === undefined ) ? 0.35 : options.drag;\n\tthis.airSpeed = ( options.airSpeed === undefined ) ? 6.0 : options.airSpeed;\n\tthis.windVector = options.windVector || new THREE.Vector2( 0.0, 0.75 );\n\tthis.speed = ( options.speed === undefined ) ? 500.0 : options.speed;\n\tthis.massConservation = ( options.massConservation === undefined ) ? false : options.massConservation;\n\n\tvar size = textureWidth * textureHeight;\n\tthis.sourceData = new Uint8Array( 4 * size );\n\n\tthis.clearSources = function () {\n\n\t\tfor ( var y = 0; y < textureHeight; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < textureWidth; x ++ ) {\n\n\t\t\t\tvar i = y * textureWidth + x;\n\t\t\t\tvar stride = i * 4;\n\n\t\t\t\tthis.sourceData[ stride ] = 0;\n\t\t\t\tthis.sourceData[ stride + 1 ] = 0;\n\t\t\t\tthis.sourceData[ stride + 2 ] = 0;\n\t\t\t\tthis.sourceData[ stride + 3 ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.sourceMaterial.uniforms.sourceMap.value = this.internalSource;\n\t\tthis.sourceMaterial.needsUpdate = true;\n\n\t\treturn this.sourceData;\n\n\t};\n\n\tthis.addSource = function ( u, v, radius, density = null, windX = null, windY = null ) {\n\n\t\tvar startX = Math.max( Math.floor( ( u - radius ) * textureWidth ), 0 );\n\t\tvar startY = Math.max( Math.floor( ( v - radius ) * textureHeight ), 0 );\n\t\tvar endX = Math.min( Math.floor( ( u + radius ) * textureWidth ), textureWidth );\n\t\tvar endY = Math.min( Math.floor( ( v + radius ) * textureHeight ), textureHeight );\n\n\t\tfor ( var y = startY; y < endY; y ++ ) {\n\n\t\t\tfor ( var x = startX; x < endX; x ++ ) {\n\n\t\t\t\tvar diffX = x * oneOverWidth - u;\n\t\t\t\tvar diffY = y * oneOverHeight - v;\n\n\t\t\t\tif ( diffX * diffX + diffY * diffY < radius * radius ) {\n\n\t\t\t\t\tvar i = y * textureWidth + x;\n\t\t\t\t\tvar stride = i * 4;\n\n\t\t\t\t\tif ( density != null ) {\n\n\t\t\t\t\t\tthis.sourceData[ stride ] = Math.min( Math.max( density, 0.0 ), 1.0 ) * 255;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( windX != null ) {\n\n\t\t\t\t\t\tvar wind = Math.min( Math.max( windX, - 1.0 ), 1.0 );\n\t\t\t\t\t\twind = ( wind < 0.0 ) ? Math.floor( wind * 127 ) + 255 : Math.floor( wind * 127 );\n\t\t\t\t\t\tthis.sourceData[ stride + 1 ] = wind;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( windY != null ) {\n\n\t\t\t\t\t\tvar wind = Math.min( Math.max( windY, - 1.0 ), 1.0 );\n\t\t\t\t\t\twind = ( wind < 0.0 ) ? Math.floor( wind * 127 ) + 255 : Math.floor( wind * 127 );\n\t\t\t\t\t\tthis.sourceData[ stride + 2 ] = wind;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.internalSource.needsUpdate = true;\n\n\t\treturn this.sourceData;\n\n\t};\n\n\t// When setting source map, red channel is density. Green and blue channels\n\t// encode x and y velocity respectively as signed chars:\n\t// (0 -> 127 = 0.0 -> 1.0, 128 -> 255 = -1.0 -> 0.0 )\n\tthis.setSourceMap = function ( texture ) {\n\n\t\tthis.sourceMaterial.uniforms.sourceMap.value = texture;\n\n\t};\n\n\tvar parameters = {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false\n\t};\n\n\n\tthis.field0 = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tthis.field0.background = new THREE.Color( 0x000000 );\n\n\tthis.field1 = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tthis.field0.background = new THREE.Color( 0x000000 );\n\n\tthis.fieldProj = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tthis.field0.background = new THREE.Color( 0x000000 );\n\n\tif ( ! THREE.Math.isPowerOfTwo( textureWidth ) ||\n\t\t ! THREE.Math.isPowerOfTwo( textureHeight ) ) {\n\n\t\tthis.field0.texture.generateMipmaps = false;\n\t\tthis.field1.texture.generateMipmaps = false;\n\t\tthis.fieldProj.texture.generateMipmaps = false;\n\n\t}\n\n\n\tthis.fieldScene = new THREE.Scene();\n\tthis.fieldScene.background = new THREE.Color( 0x000000 );\n\n\tthis.orthoCamera = new THREE.OrthographicCamera( textureWidth / - 2, textureWidth / 2, textureHeight / 2, textureHeight / - 2, 1, 2 );\n\tthis.orthoCamera.position.z = 1;\n\n\tthis.fieldGeometry = new THREE.PlaneBufferGeometry( textureWidth, textureHeight );\n\n\tthis.internalSource = new THREE.DataTexture( this.sourceData, textureWidth, textureHeight, THREE.RGBAFormat );\n\n\t// Source Shader\n\n\tvar shader = THREE.Fire.SourceShader;\n\tthis.sourceMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\tthis.clearSources();\n\n\tthis.sourceMesh = new THREE.Mesh( this.fieldGeometry, this.sourceMaterial );\n\tthis.fieldScene.add( this.sourceMesh );\n\n\t// Diffuse Shader\n\n\tvar shader = THREE.Fire.DiffuseShader;\n\tthis.diffuseMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\tthis.diffuseMaterial.uniforms.oneOverWidth.value = oneOverWidth;\n\tthis.diffuseMaterial.uniforms.oneOverHeight.value = oneOverHeight;\n\n\tthis.diffuseMesh = new THREE.Mesh( this.fieldGeometry, this.diffuseMaterial );\n\tthis.fieldScene.add( this.diffuseMesh );\n\n\t// Drift Shader\n\n\tshader = THREE.Fire.DriftShader;\n\tthis.driftMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\tthis.driftMaterial.uniforms.oneOverWidth.value = oneOverWidth;\n\tthis.driftMaterial.uniforms.oneOverHeight.value = oneOverHeight;\n\n\tthis.driftMesh = new THREE.Mesh( this.fieldGeometry, this.driftMaterial );\n\tthis.fieldScene.add( this.driftMesh );\n\n\t// Projection Shader 1\n\n\tshader = THREE.Fire.ProjectionShader1;\n\tthis.projMaterial1 = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\tthis.projMaterial1.uniforms.oneOverWidth.value = oneOverWidth;\n\tthis.projMaterial1.uniforms.oneOverHeight.value = oneOverHeight;\n\n\tthis.projMesh1 = new THREE.Mesh( this.fieldGeometry, this.projMaterial1 );\n\tthis.fieldScene.add( this.projMesh1 );\n\n\t// Projection Shader 2\n\n\tshader = THREE.Fire.ProjectionShader2;\n\tthis.projMaterial2 = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\n\tthis.projMaterial2.uniforms.oneOverWidth.value = oneOverWidth;\n\tthis.projMaterial2.uniforms.oneOverHeight.value = oneOverHeight;\n\n\tthis.projMesh2 = new THREE.Mesh( this.fieldGeometry, this.projMaterial2 );\n\tthis.fieldScene.add( this.projMesh2 );\n\n\t// Projection Shader 3\n\n\tshader = THREE.Fire.ProjectionShader3;\n\tthis.projMaterial3 = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: false\n\t} );\n\n\n\tthis.projMaterial3.uniforms.oneOverWidth.value = oneOverWidth;\n\tthis.projMaterial3.uniforms.oneOverHeight.value = oneOverHeight;\n\n\tthis.projMesh3 = new THREE.Mesh( this.fieldGeometry, this.projMaterial3 );\n\tthis.fieldScene.add( this.projMesh3 );\n\n\t// Color Shader\n\n\tif ( debug ) {\n\n\t\tshader = THREE.Fire.DebugShader;\n\n\t} else {\n\n\t\tshader = THREE.Fire.ColorShader;\n\n\t}\n\tthis.material = new THREE.ShaderMaterial( {\n\t\tuniforms: shader.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: true\n\t} );\n\n\tthis.material.uniforms.densityMap.value = this.field1.texture;\n\n\tthis.configShaders = function ( dt ) {\n\n\t\tthis.diffuseMaterial.uniforms.diffuse.value = dt * 0.05 * this.diffuse;\n\t\tthis.diffuseMaterial.uniforms.viscosity.value = dt * 0.05 * this.viscosity;\n\t\tthis.diffuseMaterial.uniforms.expansion.value = Math.exp( this.expansion * - 1.0 );\n\t\tthis.diffuseMaterial.uniforms.swirl.value = Math.exp( this.swirl * - 0.1 );\n\t\tthis.diffuseMaterial.uniforms.drag.value = Math.exp( this.drag * - 0.1 );\n\t\tthis.diffuseMaterial.uniforms.burnRate.value = this.burnRate * dt * 0.01;\n\t\tthis.driftMaterial.uniforms.windVector.value = this.windVector;\n\t\tthis.driftMaterial.uniforms.airSpeed.value = dt * this.airSpeed * 0.001 * textureHeight;\n\t\tthis.material.uniforms.color1.value = this.color1;\n\t\tthis.material.uniforms.color2.value = this.color2;\n\t\tthis.material.uniforms.color3.value = this.color3;\n\t\tthis.material.uniforms.colorBias.value = this.colorBias;\n\n\t};\n\n\tthis.clearDiffuse = function () {\n\n\t\tthis.diffuseMaterial.uniforms.expansion.value = 1.0;\n\t\tthis.diffuseMaterial.uniforms.swirl.value = 1.0;\n\t\tthis.diffuseMaterial.uniforms.drag.value = 1.0;\n\t\tthis.diffuseMaterial.uniforms.burnRate.value = 0.0;\n\n\t};\n\n\tthis.swapTextures = function () {\n\n\t\tvar swap = this.field0;\n\t\tthis.field0 = this.field1;\n\t\tthis.field1 = swap;\n\n\t};\n\n\tthis.saveRenderState = function ( renderer ) {\n\n\t\tthis.savedRenderTarget = renderer.getRenderTarget();\n\t\tthis.savedVrEnabled = renderer.vr.enabled;\n\t\tthis.savedShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\tthis.savedAntialias = renderer.antialias;\n\t\tthis.savedToneMapping = renderer.toneMapping;\n\n\t};\n\n\tthis.restoreRenderState = function ( renderer ) {\n\n\t\trenderer.vr.enabled = this.savedVrEnabled;\n\t\trenderer.shadowMap.autoUpdate = this.savedShadowAutoUpdate;\n\t\trenderer.setRenderTarget( this.savedRenderTarget );\n\t\trenderer.antialias = this.savedAntialias;\n\t\trenderer.toneMapping = this.savedToneMapping;\n\n\t};\n\n\tthis.renderSource = function ( renderer ) {\n\n\t\tthis.sourceMesh.visible = true;\n\n\t\tthis.sourceMaterial.uniforms.densityMap.value = this.field0.texture;\n\n\t\trenderer.render( this.fieldScene, this.orthoCamera, this.field1 );\n\n\t\tthis.sourceMesh.visible = false;\n\n\t\tthis.swapTextures();\n\n\t};\n\n\tthis.renderDiffuse = function ( renderer ) {\n\n\t\tthis.diffuseMesh.visible = true;\n\n\t\tthis.diffuseMaterial.uniforms.densityMap.value = this.field0.texture;\n\n\t\trenderer.render( this.fieldScene, this.orthoCamera, this.field1 );\n\n\t\tthis.diffuseMesh.visible = false;\n\n\t\tthis.swapTextures();\n\n\t};\n\n\tthis.renderDrift = function ( renderer ) {\n\n\t\tthis.driftMesh.visible = true;\n\n\t\tthis.driftMaterial.uniforms.densityMap.value = this.field0.texture;\n\n\t\trenderer.render( this.fieldScene, this.orthoCamera, this.field1 );\n\n\t\tthis.driftMesh.visible = false;\n\n\t\tthis.swapTextures();\n\n\t};\n\n\tthis.renderProject = function ( renderer ) {\n\n\t\t// Projection pass 1\n\n\t\tthis.projMesh1.visible = true;\n\n\t\tthis.projMaterial1.uniforms.densityMap.value = this.field0.texture;\n\n\t\trenderer.render( this.fieldScene, this.orthoCamera, this.fieldProj );\n\n\t\tthis.projMesh1.visible = false;\n\n\t\tthis.projMaterial2.uniforms.densityMap.value = this.fieldProj.texture;\n\n\t\t// Projection pass 2\n\n\t\tthis.projMesh2.visible = true;\n\n\t\tfor ( var i = 0; i < 20; i ++ ) {\n\n\t\t\trenderer.render( this.fieldScene, this.orthoCamera, this.field1 );\n\n\t\t\tvar temp = this.field1;\n\t\t\tthis.field1 = this.fieldProj;\n\t\t\tthis.fieldProj = temp;\n\n\t\t\tthis.projMaterial2.uniforms.densityMap.value = this.fieldProj.texture;\n\n\t\t}\n\n\t\tthis.projMesh2.visible = false;\n\n\t\tthis.projMaterial3.uniforms.densityMap.value = this.field0.texture;\n\t\tthis.projMaterial3.uniforms.projMap.value = this.fieldProj.texture;\n\n\t\t// Projection pass 3\n\n\t\tthis.projMesh3.visible = true;\n\n\t\trenderer.render( this.fieldScene, this.orthoCamera, this.field1 );\n\n\t\tthis.projMesh3.visible = false;\n\n\t\tthis.swapTextures();\n\n\t};\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\tvar delta = this.clock.getDelta();\n\t\tif ( delta > 0.1 ) {\n\n\t\t\tdelta = 0.1;\n\n\t\t}\n\t\tvar dt = delta * ( this.speed * 0.1 );\n\n\t\tthis.configShaders( dt );\n\n\t\tthis.saveRenderState( renderer );\n\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\trenderer.antialias = false;\n\t\trenderer.toneMapping = THREE.NoToneMapping;\n\n\t\tthis.sourceMesh.visible = false;\n\t\tthis.diffuseMesh.visible = false;\n\t\tthis.driftMesh.visible = false;\n\t\tthis.projMesh1.visible = false;\n\t\tthis.projMesh2.visible = false;\n\t\tthis.projMesh3.visible = false;\n\n\t\tthis.renderSource( renderer );\n\n\t\tthis.clearDiffuse();\n\t\tfor ( var i = 0; i < 21; i ++ ) {\n\n\t\t\tthis.renderDiffuse( renderer );\n\n\t\t}\n\t\tthis.configShaders( dt );\n\t\tthis.renderDiffuse( renderer );\n\n\t\tthis.renderDrift( renderer );\n\n\t\tif ( this.massConservation ) {\n\n\t\t\tthis.renderProject( renderer );\n\t\t\tthis.renderProject( renderer );\n\n\t\t}\n\n\t\t// Final result out for coloring\n\n\t\tthis.material.map = this.field1.texture;\n\t\tthis.material.transparent = true;\n\t\tthis.material.minFilter = THREE.LinearFilter,\n\t\tthis.material.magFilter = THREE.LinearFilter,\n\n\t\tthis.restoreRenderState( renderer );\n\n\t};\n\n};\n\n\nTHREE.Fire.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Fire.prototype.constructor = THREE.Fire;\n\nTHREE.Fire.SourceShader = {\n\n\tuniforms: {\n\t\t'sourceMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform sampler2D sourceMap;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    vec4 source = texture2D( sourceMap, vUv );',\n\t\t'    vec4 current = texture2D( densityMap, vUv );',\n\n\t\t'    vec2 v0 = (current.gb - step(0.5, current.gb)) * 2.0;',\n\t\t'    vec2 v1 = (source.gb - step(0.5, source.gb)) * 2.0;',\n\n\t\t'    vec2 newVel = v0 + v1;',\n\n\t\t'    newVel = clamp(newVel, -0.99, 0.99);',\n\t\t'    newVel = newVel * 0.5 + step(0.0, -newVel);',\n\n\t\t'    float newDensity = source.r + current.a;',\n\t\t'    float newTemp = source.r + current.r;',\n\n\t\t'    newDensity = clamp(newDensity, 0.0, 1.0);',\n\t\t'    newTemp = clamp(newTemp, 0.0, 1.0);',\n\n\t\t'    gl_FragColor = vec4(newTemp, newVel.xy, newDensity);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\n\nTHREE.Fire.DiffuseShader = {\n\n\tuniforms: {\n\t\t'oneOverWidth': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'oneOverHeight': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'diffuse': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'viscosity': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'expansion': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'swirl': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'drag': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'burnRate': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform float oneOverWidth;',\n\t\t'uniform float oneOverHeight;',\n\t\t'uniform float diffuse;',\n\t\t'uniform float viscosity;',\n\t\t'uniform float expansion;',\n\t\t'uniform float swirl;',\n\t\t'uniform float burnRate;',\n\t\t'uniform float drag;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t'    vec4 dC = texture2D( densityMap, vUv );',\n\t\t'    vec4 dL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) );',\n\t\t'    vec4 dR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) );',\n\t\t'    vec4 dU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) );',\n\t\t'    vec4 dD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) );',\n\t\t'    vec4 dUL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y - oneOverHeight) );',\n\t\t'    vec4 dUR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y - oneOverHeight) );',\n\t\t'    vec4 dDL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y + oneOverHeight) );',\n\t\t'    vec4 dDR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y + oneOverHeight) );',\n\n\t\t'    dC.yz = (dC.yz - step(0.5, dC.yz)) * 2.0;',\n\t\t'    dL.yz = (dL.yz - step(0.5, dL.yz)) * 2.0;',\n\t\t'    dR.yz = (dR.yz - step(0.5, dR.yz)) * 2.0;',\n\t\t'    dU.yz = (dU.yz - step(0.5, dU.yz)) * 2.0;',\n\t\t'    dD.yz = (dD.yz - step(0.5, dD.yz)) * 2.0;',\n\t\t'    dUL.yz = (dUL.yz - step(0.5, dUL.yz)) * 2.0;',\n\t\t'    dUR.yz = (dUR.yz - step(0.5, dUR.yz)) * 2.0;',\n\t\t'    dDL.yz = (dDL.yz - step(0.5, dDL.yz)) * 2.0;',\n\t\t'    dDR.yz = (dDR.yz - step(0.5, dDR.yz)) * 2.0;',\n\n\t\t'    vec4 result = (dC + vec4(diffuse, viscosity, viscosity, diffuse) * ( dL + dR + dU + dD + dUL + dUR + dDL + dDR )) / (1.0 + 8.0 * vec4(diffuse, viscosity, viscosity, diffuse)) - vec4(0.0, 0.0, 0.0, 0.001);',\n\n\t\t'    float temperature = result.r;',\n\t\t'    temperature = clamp(temperature - burnRate, 0.0, 1.0);',\n\n\t\t'    vec2 velocity = result.yz;',\n\n\t\t'    vec2 expansionVec = vec2(dL.w - dR.w, dU.w - dD.w);',\n\n\t\t'    vec2 swirlVec = vec2((dL.z - dR.z) * 0.5, (dU.y - dD.y) * 0.5);',\n\n\t\t'    velocity = velocity + (1.0 - expansion) * expansionVec + (1.0 - swirl) * swirlVec;',\n\n\t\t'    velocity = velocity - (1.0 - drag) * velocity;',\n\n\t\t'    gl_FragColor = vec4(temperature, velocity * 0.5 + step(0.0, -velocity), result.w);',\n\n\t\t'    gl_FragColor = gl_FragColor * step(oneOverWidth, vUv.x);',\n\t\t'    gl_FragColor = gl_FragColor * step(oneOverHeight, vUv.y);',\n\t\t'    gl_FragColor = gl_FragColor * step(vUv.x, 1.0 - oneOverWidth);',\n\t\t'    gl_FragColor = gl_FragColor * step(vUv.y, 1.0 - oneOverHeight);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\nTHREE.Fire.DriftShader = {\n\n\tuniforms: {\n\t\t'oneOverWidth': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'oneOverHeight': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'windVector': {\n\t\t\ttype: 'v2',\n\t\t\tvalue: new THREE.Vector2( 0.0, 0.0 )\n\t\t},\n\t\t'airSpeed': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform float oneOverWidth;',\n\t\t'uniform float oneOverHeight;',\n\t\t'uniform vec2 windVector;',\n\t\t'uniform float airSpeed;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    vec2 velocity = texture2D( densityMap, vUv ).gb;',\n\t\t'    velocity = (velocity - step(0.5, velocity)) * 2.0;',\n\n\t\t'    velocity = velocity + windVector;',\n\n\t\t'    vec2 sourcePos = vUv - airSpeed * vec2(oneOverWidth, oneOverHeight) * velocity;',\n\n\t\t'    vec2 units = sourcePos / vec2(oneOverWidth, oneOverHeight);',\n\n\t\t'    vec2 intPos = floor(units);',\n\t\t'    vec2 frac = units - intPos;',\n\t\t'    intPos = intPos * vec2(oneOverWidth, oneOverHeight);',\n\n\t\t'    vec4 dX0Y0 = texture2D( densityMap, intPos + vec2(0.0, -oneOverHeight) );',\n\t\t'    vec4 dX1Y0 = texture2D( densityMap, intPos + vec2(oneOverWidth, 0.0) );',\n\t\t'    vec4 dX0Y1 = texture2D( densityMap, intPos + vec2(0.0, oneOverHeight) );',\n\t\t'    vec4 dX1Y1 = texture2D( densityMap, intPos + vec2(oneOverWidth, oneOverHeight) );',\n\n\n\t\t'    dX0Y0.gb = (dX0Y0.gb - step(0.5, dX0Y0.gb)) * 2.0;',\n\t\t'    dX1Y0.gb = (dX1Y0.gb - step(0.5, dX1Y0.gb)) * 2.0;',\n\t\t'    dX0Y1.gb = (dX0Y1.gb - step(0.5, dX0Y1.gb)) * 2.0;',\n\t\t'    dX1Y1.gb = (dX1Y1.gb - step(0.5, dX1Y1.gb)) * 2.0;',\n\n\t\t'    vec4 source = mix(mix(dX0Y0, dX1Y0, frac.x), mix(dX0Y1, dX1Y1, frac.x), frac.y);',\n\n\t\t'    source.gb = source.gb * 0.5 + step(0.0, -source.gb);',\n\n\t\t'    gl_FragColor = source;',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\n\nTHREE.Fire.ProjectionShader1 = {\n\n\tuniforms: {\n\t\t'oneOverWidth': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'oneOverHeight': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform float oneOverWidth;',\n\t\t'uniform float oneOverHeight;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    float dL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',\n\t\t'    float dR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',\n\t\t'    float dU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) ).b;',\n\t\t'    float dD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) ).b;',\n\n\t\t'    dL = (dL - step(0.5, dL)) * 2.0;',\n\t\t'    dR = (dR - step(0.5, dR)) * 2.0;',\n\t\t'    dU = (dU - step(0.5, dU)) * 2.0;',\n\t\t'    dD = (dD - step(0.5, dD)) * 2.0;',\n\n\t\t'    float h = (oneOverWidth + oneOverHeight) * 0.5;',\n\t\t'    float div = -0.5 * h * (dR - dL + dD - dU);',\n\n\t\t'    gl_FragColor = vec4( 0.0, 0.0, div * 0.5 + step(0.0, -div), 0.0);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\n\nTHREE.Fire.ProjectionShader2 = {\n\n\tuniforms: {\n\t\t'oneOverWidth': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'oneOverHeight': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform float oneOverWidth;',\n\t\t'uniform float oneOverHeight;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    float div = texture2D( densityMap, vUv ).b;',\n\t\t'    float pL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',\n\t\t'    float pR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',\n\t\t'    float pU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) ).g;',\n\t\t'    float pD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) ).g;',\n\n\t\t'    float divNorm = (div - step(0.5, div)) * 2.0;',\n\t\t'    pL = (pL - step(0.5, pL)) * 2.0;',\n\t\t'    pR = (pR - step(0.5, pR)) * 2.0;',\n\t\t'    pU = (pU - step(0.5, pU)) * 2.0;',\n\t\t'    pD = (pD - step(0.5, pD)) * 2.0;',\n\n\t\t'    float p = (divNorm + pR + pL + pD + pU) * 0.25;',\n\n\t\t'    gl_FragColor = vec4( 0.0, p * 0.5 + step(0.0, -p), div, 0.0);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\n\nTHREE.Fire.ProjectionShader3 = {\n\n\tuniforms: {\n\t\t'oneOverWidth': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'oneOverHeight': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\t\t'projMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform float oneOverWidth;',\n\t\t'uniform float oneOverHeight;',\n\t\t'uniform sampler2D densityMap;',\n\t\t'uniform sampler2D projMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    vec4 orig = texture2D(densityMap, vUv);',\n\n\t\t'    float pL = texture2D( projMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',\n\t\t'    float pR = texture2D( projMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',\n\t\t'    float pU = texture2D( projMap, vec2(vUv.x, vUv.y - oneOverHeight) ).g;',\n\t\t'    float pD = texture2D( projMap, vec2(vUv.x, vUv.y + oneOverHeight) ).g;',\n\n\t\t'    float uNorm = (orig.g - step(0.5, orig.g)) * 2.0;',\n\t\t'    float vNorm = (orig.b - step(0.5, orig.b)) * 2.0;',\n\n\t\t'    pL = (pL - step(0.5, pL)) * 2.0;',\n\t\t'    pR = (pR - step(0.5, pR)) * 2.0;',\n\t\t'    pU = (pU - step(0.5, pU)) * 2.0;',\n\t\t'    pD = (pD - step(0.5, pD)) * 2.0;',\n\n\t\t'    float h = (oneOverWidth + oneOverHeight) * 0.5;',\n\t\t'    float u = uNorm - (0.5 * (pR - pL) / h);',\n\t\t'    float v = vNorm - (0.5 * (pD - pU) / h);',\n\n\t\t'    gl_FragColor = vec4( orig.r, u * 0.5 + step(0.0, -u), v * 0.5 + step(0.0, -v), orig.a);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\nTHREE.Fire.ColorShader = {\n\n\tuniforms: {\n\t\t'color1': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'color2': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'color3': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'colorBias': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color1;',\n\t\t'uniform vec3 color2;',\n\t\t'uniform vec3 color3;',\n\t\t'uniform float colorBias;',\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    float density = texture2D( densityMap, vUv ).a;',\n\t\t'    float temperature = texture2D( densityMap, vUv ).r;',\n\n\t\t'    float bias = clamp(colorBias, 0.0001, 0.9999);',\n\n\t\t'    vec3 blend1 = mix(color3, color2, temperature / bias) * (1.0 - step(bias, temperature));',\n\t\t'    vec3 blend2 = mix(color2, color1, (temperature - bias) / (1.0 - bias) ) * step(bias, temperature);',\n\n\t\t'    gl_FragColor = vec4(blend1 + blend2, density);',\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n\n\nTHREE.Fire.DebugShader = {\n\n\tuniforms: {\n\t\t'color1': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'color2': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'color3': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\t\t'colorBias': {\n\t\t\ttype: 'f',\n\t\t\tvalue: null\n\t\t},\n\t\t'densityMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t}\n\t},\n\n\tvertexShader: [\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t' \t  vUv = uv;',\n\n\t\t'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t'     gl_Position = projectionMatrix * mvPosition;',\n\n\t\t'}'\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t'uniform sampler2D densityMap;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\t\t'    float density;',\n\t\t'    density = texture2D( densityMap, vUv ).a;',\n\n\t\t'    vec2 vel = texture2D( densityMap, vUv ).gb;',\n\n\t\t'    vel = (vel - step(0.5, vel)) * 2.0;',\n\n\t\t'    float r = density;',\n\t\t'    float g = max(abs(vel.x), density * 0.5);',\n\t\t'    float b = max(abs(vel.y), density * 0.5);',\n\t\t'    float a = max(density * 0.5, max(abs(vel.x), abs(vel.y)));',\n\n\t\t'    gl_FragColor = vec4(r, g, b, a);',\n\n\t\t'}'\n\n\t].join( \"\\n\" )\n};\n"]}